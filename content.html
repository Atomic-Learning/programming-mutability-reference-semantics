
<p>In languages with <strong>reference semantics</strong> (like Python, Java, JavaScript, and Ruby), variables don't directly contain dataâ€”they contain references to objects in memory. This distinction becomes especially important when combined with mutability.</p>

<h2>Variables as References</h2>

<p>In reference-semantic languages, when you assign a value to a variable, the variable holds a reference (or pointer) to an object in memory, not the object itself:</p>

<pre><code>x = [1, 2, 3]              // x references a list object in memory
y = x                      // y references the SAME list object</code></pre>

<p>Both <code>x</code> and <code>y</code> now refer to the same underlying list object in memory.</p>

<h2>The Aliasing Effect with Mutable Objects</h2>

<p><strong>Aliasing</strong> occurs when multiple variables refer to the same mutable object. As a consequence, modifications made through one variable will be visible through all of them:</p>

<pre><code>list1 = [1, 2, 3]
list2 = list1              // list2 refers to the SAME list as list1
list2[0] = 10              // Modify the first item of the list through list2
PRINT list1[0]             // Output: 10 (list1 saw the change!)</code></pre>

<p>This behavior can be surprising: you modified <code>list2</code>, but <code>list1</code> changed too because they're two variables which reference the same object.</p>

<h2>Immutable Objects Avoid Aliasing Issues</h2>

<p>With immutable objects, aliasing doesn't work the same way because the object can't be changed:</p>

<pre><code>string1 = "hello"
string2 = string1          // Both refer to the same string
string2 = "goodbye"        // Creates a NEW string, assigns to string2
PRINT string1              // Output: "hello" (unchanged)</code></pre>

<p>When you "modify" an immutable object, you're actually creating a new object and reassigning the variable. The original object remains unchanged.</p>